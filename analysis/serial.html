<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>串口 | GRBL 源码解析与移植</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="/logo.png">
    <meta name="description" content="GRBL源码精度与解析，代码行级中文注释并提供丰富详尽的案例展示。">
    
    <link rel="preload" href="/assets/css/0.styles.8f3dca9f.css" as="style"><link rel="preload" href="/assets/js/app.51868380.js" as="script"><link rel="preload" href="/assets/js/2.495ffcb8.js" as="script"><link rel="preload" href="/assets/js/1.65b8fb93.js" as="script"><link rel="preload" href="/assets/js/39.5056282f.js" as="script"><link rel="prefetch" href="/assets/js/10.e5f0c1f9.js"><link rel="prefetch" href="/assets/js/11.d74d0da6.js"><link rel="prefetch" href="/assets/js/12.b8e4f81b.js"><link rel="prefetch" href="/assets/js/13.814df329.js"><link rel="prefetch" href="/assets/js/14.5246fb06.js"><link rel="prefetch" href="/assets/js/15.46074ed7.js"><link rel="prefetch" href="/assets/js/16.6a188078.js"><link rel="prefetch" href="/assets/js/17.2e0240b0.js"><link rel="prefetch" href="/assets/js/18.f10ed367.js"><link rel="prefetch" href="/assets/js/19.e1261ca5.js"><link rel="prefetch" href="/assets/js/20.bdd28f89.js"><link rel="prefetch" href="/assets/js/21.e77d95ae.js"><link rel="prefetch" href="/assets/js/22.5d54bc34.js"><link rel="prefetch" href="/assets/js/23.fb7a741a.js"><link rel="prefetch" href="/assets/js/24.533671ad.js"><link rel="prefetch" href="/assets/js/25.8a64622f.js"><link rel="prefetch" href="/assets/js/26.ddbc1448.js"><link rel="prefetch" href="/assets/js/27.d466dc4d.js"><link rel="prefetch" href="/assets/js/28.6f391f4d.js"><link rel="prefetch" href="/assets/js/29.9f864af6.js"><link rel="prefetch" href="/assets/js/3.dfa179b7.js"><link rel="prefetch" href="/assets/js/30.cc2da9d2.js"><link rel="prefetch" href="/assets/js/31.1ee29fde.js"><link rel="prefetch" href="/assets/js/32.c5f715f7.js"><link rel="prefetch" href="/assets/js/33.72970865.js"><link rel="prefetch" href="/assets/js/34.6a905609.js"><link rel="prefetch" href="/assets/js/35.ed20c0d4.js"><link rel="prefetch" href="/assets/js/36.d527e604.js"><link rel="prefetch" href="/assets/js/37.859790bf.js"><link rel="prefetch" href="/assets/js/38.969727cd.js"><link rel="prefetch" href="/assets/js/4.b28b260a.js"><link rel="prefetch" href="/assets/js/40.c5fb4687.js"><link rel="prefetch" href="/assets/js/41.e767ad87.js"><link rel="prefetch" href="/assets/js/42.62eddc71.js"><link rel="prefetch" href="/assets/js/43.37e74c0f.js"><link rel="prefetch" href="/assets/js/44.d0cde5f8.js"><link rel="prefetch" href="/assets/js/45.443aca08.js"><link rel="prefetch" href="/assets/js/46.1c5cd450.js"><link rel="prefetch" href="/assets/js/47.d216d9c9.js"><link rel="prefetch" href="/assets/js/48.6d973115.js"><link rel="prefetch" href="/assets/js/49.5a017e5d.js"><link rel="prefetch" href="/assets/js/5.5394f6ea.js"><link rel="prefetch" href="/assets/js/50.8e776fb6.js"><link rel="prefetch" href="/assets/js/51.65f71142.js"><link rel="prefetch" href="/assets/js/52.55d0527a.js"><link rel="prefetch" href="/assets/js/53.2247ca40.js"><link rel="prefetch" href="/assets/js/54.f5cec60a.js"><link rel="prefetch" href="/assets/js/55.153a8391.js"><link rel="prefetch" href="/assets/js/56.d6c8da6a.js"><link rel="prefetch" href="/assets/js/57.053e13d2.js"><link rel="prefetch" href="/assets/js/58.b645bf38.js"><link rel="prefetch" href="/assets/js/59.d889b669.js"><link rel="prefetch" href="/assets/js/6.5efdfc70.js"><link rel="prefetch" href="/assets/js/60.6ef94c27.js"><link rel="prefetch" href="/assets/js/7.91537c65.js"><link rel="prefetch" href="/assets/js/vendors~docsearch.6fed1ae2.js">
    <link rel="stylesheet" href="/assets/css/0.styles.8f3dca9f.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/logo.png" alt="GRBL 源码解析与移植" class="logo"> <span class="site-name can-hide">GRBL 源码解析与移植</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/donate/" class="nav-link">
  打赏
</a></div><div class="nav-item"><a href="https://github.com/MillerRen/grbl" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GRBL中文注解
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://github.com/MillerRen/grbl-learning" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/donate/" class="nav-link">
  打赏
</a></div><div class="nav-item"><a href="https://github.com/MillerRen/grbl" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GRBL中文注解
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://github.com/MillerRen/grbl-learning" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/" aria-current="page" class="sidebar-link">首页</a></li><li><a href="/preface.html" class="sidebar-link">前言</a></li><li><a href="/prepare.html" class="sidebar-link">准备工作</a></li><li><section class="sidebar-group collapsable depth-0"><a href="/analysis/" class="sidebar-heading clickable router-link-active open"><span>GRBL源码解析</span> <span class="arrow down"></span></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/analysis/" aria-current="page" class="sidebar-link">开始</a></li><li><a href="/analysis/architecture.html" class="sidebar-link">架构</a></li><li><a href="/analysis/main.html" class="sidebar-link">入口</a></li><li><a href="/analysis/serial.html" aria-current="page" class="active sidebar-link">串口</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/analysis/serial.html#串口配置" class="sidebar-link">串口配置</a></li><li class="sidebar-sub-header"><a href="/analysis/serial.html#环形队列" class="sidebar-link">环形队列</a></li></ul></li><li><a href="/analysis/protocol.html" class="sidebar-link">协议-主循环</a></li><li><a href="/analysis/gcode.html" class="sidebar-link">G代码解析</a></li><li><a href="/analysis/motion.html" class="sidebar-link">运动控制</a></li><li><a href="/analysis/planner.html" class="sidebar-link">运动规划</a></li><li><a href="/analysis/acceleration.html" class="sidebar-link">加速度算法</a></li><li><a href="/analysis/bresenham.html" class="sidebar-link">bresenham插值算法</a></li><li><a href="/analysis/stepper.html" class="sidebar-link">运动执行-步进电机</a></li><li><a href="/analysis/spindle.html" class="sidebar-link">主轴</a></li><li><a href="/analysis/coolant.html" class="sidebar-link">冷却</a></li><li><a href="/analysis/endstop.html" class="sidebar-link">限位开关</a></li><li><a href="/analysis/homing.html" class="sidebar-link">归位</a></li><li><a href="/analysis/probe.html" class="sidebar-link">对刀</a></li><li><a href="/analysis/emergency.html" class="sidebar-link">安全-紧急事件</a></li><li><a href="/analysis/settings.html" class="sidebar-link">参数设置</a></li><li><a href="/analysis/interface.html" class="sidebar-link">上位机接口</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/porting/" class="sidebar-heading clickable"><span>GRBL移植</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/extensions/" class="sidebar-heading clickable"><span>GRBL扩展</span> <span class="arrow right"></span></a> <!----></section></li><li><a href="/appendix/" class="sidebar-link">附录</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="串口"><a href="#串口" class="header-anchor">#</a> 串口</h1> <p>grbl使用串口从上位机接收信息，并通过串口反馈给上位机。共分为以下几部分：1.串口的配置，如波特率、停止位、校验位等；2.使用<code>环形队列</code> 作为缓冲器，用以匹配上位机和单片机的速度差异，分为输入缓冲器和输出缓冲器； 3.串口数据的简单分配，即分为实时响应和普通响应（放入队列）。</p> <h2 id="串口配置"><a href="#串口配置" class="header-anchor">#</a> 串口配置</h2> <ol><li><h3 id="串口初始化"><a href="#串口初始化" class="header-anchor">#</a> 串口初始化</h3></li></ol> <div class="language-c extra-class"><pre class="language-c"><code><span class="token comment">// 串口初始化</span>
<span class="token keyword">void</span> <span class="token function">serial_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token comment">// 设置波特率</span>
  <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression">BAUD_RATE <span class="token operator">&lt;</span> <span class="token number">57600</span></span></span>
    <span class="token class-name">uint16_t</span> UBRR0_value <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>F_CPU <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token number">8L</span> <span class="token operator">*</span> BAUD_RATE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span> <span class="token punctuation">;</span>
    UCSR0A <span class="token operator">&amp;=</span> <span class="token operator">~</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> U2X0<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 关闭波特率倍增器。 - 只在Uno xxx上需要。</span>
  <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>
    <span class="token class-name">uint16_t</span> UBRR0_value <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>F_CPU <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token number">4L</span> <span class="token operator">*</span> BAUD_RATE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>
    UCSR0A <span class="token operator">|=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> U2X0<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 波特率高的波特率倍增器开启，即115200</span>
  <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
  <span class="token comment">// 波特率是比较大的数字，需要两个8位寄存器存放</span>
  UBRR0H <span class="token operator">=</span> UBRR0_value <span class="token operator">&gt;&gt;</span> <span class="token number">8</span><span class="token punctuation">;</span> <span class="token comment">// 高8位右移到低8位，放入高8位寄存器，右移不会改变源数值</span>
  UBRR0L <span class="token operator">=</span> UBRR0_value<span class="token punctuation">;</span> <span class="token comment">// 第八位直接放入低8位寄存器</span>

  <span class="token comment">// 启用接收，发送和接收完成一个字节的中断</span>
  UCSR0B <span class="token operator">|=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span>RXEN0 <span class="token operator">|</span> <span class="token number">1</span><span class="token operator">&lt;&lt;</span>TXEN0 <span class="token operator">|</span> <span class="token number">1</span><span class="token operator">&lt;&lt;</span>RXCIE0<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 默认协议是8位，无奇偶校验，1个停止位</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>代码解析：</strong></p> <p><strong>UBRR0（串口波特率寄存器）：</strong> 这是一个16位的寄存器，需要两次分别传入一个高字节<code>UBRR0H</code>和低字节<code>UBRR0L</code>,根据公式<code>UBBR0=(F_CPU/(4*BAUD_RATE)-1)/2</code>,F_CPU设置为16000000（跟硬件一致），BAUD_RATE配置为115200，得出结果为16.36111111111111取整后得到16，跟手册Table19-12中的波特率为115200时的值16一致（注1）。
<strong>UCSR0A（串口控制及状态寄存器A）：</strong> 在高波特率时（&gt;57600）使能的波特率倍增器<code>U2X0</code>以减少误差，但是为了保证在较老的<code>Arduino</code>设备上禁用波特率倍增器用以兼容它们的bootloader。</p> <p><strong>UCSR0B（串口控制及状态寄存器B）：</strong> 使能串口接受<code>RXEN0</code>和串口发送功能<code>TXEN0</code>, 并使能串口接受完成中断<code>RXCIE0</code>，串口发送中断只在需要时开启。</p> <p><strong>UCSR0C（串口控制及状态寄存器C）：</strong> <code>UMSEL0</code>(串口模式选择位)，默认为00即异步串口， <code>UPMSEL0</code>(串口校验模式选择位)，默认为00即默认无奇偶校验。<code>USBS0</code>(串口停止位模式选择位)默认为0即1停止位。<code>UCSZ0</code>(串口字符长度寄存器)，默认为011即8位字符。这些都是默认值，不需要手动再配置。</p> <ol start="2"><li><h3 id="串口中断处理"><a href="#串口中断处理" class="header-anchor">#</a> 串口中断处理：</h3></li></ol> <p><strong>串口接收中断：</strong></p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token comment">// 串口数据接收中断处理</span>
<span class="token function">ISR</span><span class="token punctuation">(</span>SERIAL_RX<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token class-name">uint8_t</span> data <span class="token operator">=</span> UDR0<span class="token punctuation">;</span> <span class="token comment">// 从串口数据寄存器取出数据</span>
  <span class="token class-name">uint8_t</span> next_head<span class="token punctuation">;</span> <span class="token comment">// 初始化下一个头指针</span>

  <span class="token comment">// 直接从串行流中选取实时命令字符。这些字符不被传递到主缓冲区，但是它们设置了实时执行的系统状态标志位。</span>
  <span class="token keyword">switch</span> <span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> CMD_RESET<span class="token operator">:</span>         <span class="token function">mc_reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span> <span class="token comment">// 调用运动控制重置程序</span>
    <span class="token keyword">case</span> CMD_STATUS_REPORT<span class="token operator">:</span> <span class="token function">system_set_exec_state_flag</span><span class="token punctuation">(</span>EXEC_STATUS_REPORT<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span> <span class="token comment">// 状态报告</span>
    <span class="token keyword">case</span> CMD_CYCLE_START<span class="token operator">:</span>   <span class="token function">system_set_exec_state_flag</span><span class="token punctuation">(</span>EXEC_CYCLE_START<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span> <span class="token comment">// 循环开始</span>
    <span class="token keyword">case</span> CMD_FEED_HOLD<span class="token operator">:</span>     <span class="token function">system_set_exec_state_flag</span><span class="token punctuation">(</span>EXEC_FEED_HOLD<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span> <span class="token comment">// 进给保持</span>
    <span class="token keyword">default</span> <span class="token operator">:</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>data <span class="token operator">&gt;</span> <span class="token number">0x7F</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 实时控制都是扩展的ASCII字符</span>
        <span class="token keyword">switch</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">case</span> CMD_SAFETY_DOOR<span class="token operator">:</span>   <span class="token function">system_set_exec_state_flag</span><span class="token punctuation">(</span>EXEC_SAFETY_DOOR<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span> <span class="token comment">// 设置为 true</span>
          <span class="token keyword">case</span> CMD_JOG_CANCEL<span class="token operator">:</span>   
            <span class="token keyword">if</span> <span class="token punctuation">(</span>sys<span class="token punctuation">.</span>state <span class="token operator">&amp;</span> STATE_JOG<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 阻止所有其他状态，调用运动取消。</span>
              <span class="token function">system_set_exec_state_flag</span><span class="token punctuation">(</span>EXEC_MOTION_CANCEL<span class="token punctuation">)</span><span class="token punctuation">;</span> 
            <span class="token punctuation">}</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span> 
          <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">DEBUG</span></span>
            <span class="token keyword">case</span> CMD_DEBUG_REPORT<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token class-name">uint8_t</span> sreg <span class="token operator">=</span> SREG<span class="token punctuation">;</span> <span class="token function">cli</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">bit_true</span><span class="token punctuation">(</span>sys_rt_exec_debug<span class="token punctuation">,</span>EXEC_DEBUG_REPORT<span class="token punctuation">)</span><span class="token punctuation">;</span> SREG <span class="token operator">=</span> sreg<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
          <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
          <span class="token comment">// 以下为实时覆盖命令</span>
          <span class="token keyword">case</span> CMD_FEED_OVR_RESET<span class="token operator">:</span> <span class="token function">system_set_exec_motion_override_flag</span><span class="token punctuation">(</span>EXEC_FEED_OVR_RESET<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
          <span class="token keyword">case</span> CMD_FEED_OVR_COARSE_PLUS<span class="token operator">:</span> <span class="token function">system_set_exec_motion_override_flag</span><span class="token punctuation">(</span>EXEC_FEED_OVR_COARSE_PLUS<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
          <span class="token keyword">case</span> CMD_FEED_OVR_COARSE_MINUS<span class="token operator">:</span> <span class="token function">system_set_exec_motion_override_flag</span><span class="token punctuation">(</span>EXEC_FEED_OVR_COARSE_MINUS<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
          <span class="token keyword">case</span> CMD_FEED_OVR_FINE_PLUS<span class="token operator">:</span> <span class="token function">system_set_exec_motion_override_flag</span><span class="token punctuation">(</span>EXEC_FEED_OVR_FINE_PLUS<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
          <span class="token keyword">case</span> CMD_FEED_OVR_FINE_MINUS<span class="token operator">:</span> <span class="token function">system_set_exec_motion_override_flag</span><span class="token punctuation">(</span>EXEC_FEED_OVR_FINE_MINUS<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
          <span class="token keyword">case</span> CMD_RAPID_OVR_RESET<span class="token operator">:</span> <span class="token function">system_set_exec_motion_override_flag</span><span class="token punctuation">(</span>EXEC_RAPID_OVR_RESET<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
          <span class="token keyword">case</span> CMD_RAPID_OVR_MEDIUM<span class="token operator">:</span> <span class="token function">system_set_exec_motion_override_flag</span><span class="token punctuation">(</span>EXEC_RAPID_OVR_MEDIUM<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
          <span class="token keyword">case</span> CMD_RAPID_OVR_LOW<span class="token operator">:</span> <span class="token function">system_set_exec_motion_override_flag</span><span class="token punctuation">(</span>EXEC_RAPID_OVR_LOW<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
          <span class="token keyword">case</span> CMD_SPINDLE_OVR_RESET<span class="token operator">:</span> <span class="token function">system_set_exec_accessory_override_flag</span><span class="token punctuation">(</span>EXEC_SPINDLE_OVR_RESET<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
          <span class="token keyword">case</span> CMD_SPINDLE_OVR_COARSE_PLUS<span class="token operator">:</span> <span class="token function">system_set_exec_accessory_override_flag</span><span class="token punctuation">(</span>EXEC_SPINDLE_OVR_COARSE_PLUS<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
          <span class="token keyword">case</span> CMD_SPINDLE_OVR_COARSE_MINUS<span class="token operator">:</span> <span class="token function">system_set_exec_accessory_override_flag</span><span class="token punctuation">(</span>EXEC_SPINDLE_OVR_COARSE_MINUS<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
          <span class="token keyword">case</span> CMD_SPINDLE_OVR_FINE_PLUS<span class="token operator">:</span> <span class="token function">system_set_exec_accessory_override_flag</span><span class="token punctuation">(</span>EXEC_SPINDLE_OVR_FINE_PLUS<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
          <span class="token keyword">case</span> CMD_SPINDLE_OVR_FINE_MINUS<span class="token operator">:</span> <span class="token function">system_set_exec_accessory_override_flag</span><span class="token punctuation">(</span>EXEC_SPINDLE_OVR_FINE_MINUS<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
          <span class="token keyword">case</span> CMD_SPINDLE_OVR_STOP<span class="token operator">:</span> <span class="token function">system_set_exec_accessory_override_flag</span><span class="token punctuation">(</span>EXEC_SPINDLE_OVR_STOP<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
          <span class="token keyword">case</span> CMD_COOLANT_FLOOD_OVR_TOGGLE<span class="token operator">:</span> <span class="token function">system_set_exec_accessory_override_flag</span><span class="token punctuation">(</span>EXEC_COOLANT_FLOOD_OVR_TOGGLE<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
          <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">ENABLE_M7</span></span>
            <span class="token keyword">case</span> CMD_COOLANT_MIST_OVR_TOGGLE<span class="token operator">:</span> <span class="token function">system_set_exec_accessory_override_flag</span><span class="token punctuation">(</span>EXEC_COOLANT_MIST_OVR_TOGGLE<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
          <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 除了上面已知的实时命令，其他的ASCII扩展字符都被丢掉</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">// 其他的字符被认为都是G代码，会被写入到主缓冲区</span>
        next_head <span class="token operator">=</span> serial_rx_buffer_head <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 更新临时头指针</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>next_head <span class="token operator">==</span> RX_RING_BUFFER<span class="token punctuation">)</span> <span class="token punctuation">{</span> next_head <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

        <span class="token comment">// 写入到接收缓冲区，直到它满了为止。</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>next_head <span class="token operator">!=</span> serial_rx_buffer_tail<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          serial_rx_buffer<span class="token punctuation">[</span>serial_rx_buffer_head<span class="token punctuation">]</span> <span class="token operator">=</span> data<span class="token punctuation">;</span>
          serial_rx_buffer_head <span class="token operator">=</span> next_head<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>代码解析：</strong></p> <p>AVR并没有实现中断功能，中断实现是由编译器<code>gcc-avr</code>完成的，具体用法是在中断函数前用<code>__attribute__((interrupt))</code>修饰，<code>ISR(SERIAL_RX)</code>是一个宏定义，它在<code>interrupt.h</code>中定义,功能是根据传入的中断向量号生成中断函数定义和函数声明。</p> <p>开启了中断并设置了中断函数，一旦串口中接收到了一个字节数据，就会触发中断，从<code>UDR0</code>串口数据寄存器中取出数据后，会做简单区分，这里有三种类型的数据：</p> <ol><li>实时命令，不会放入串口接收队列。</li> <li>实时覆盖命令，能实时调整部分参数，也不会放入串口接收队列。</li> <li>正常的G代码和系统命令，会放入串口接收队列。</li></ol> <p><strong>串口发送中断：</strong></p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token comment">// 数据寄存器为空的中断处理</span>
<span class="token function">ISR</span><span class="token punctuation">(</span>SERIAL_UDRE<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token comment">// 由于环形队列尾指针中断和主程序都会使用，有可能导致数据读取时，指针已经发生了变化，</span>
  <span class="token comment">// 存在不稳定性，所以要用临时变量暂存，增加读取时的稳定性。</span>
  <span class="token class-name">uint8_t</span> tail <span class="token operator">=</span> serial_tx_buffer_tail<span class="token punctuation">;</span> <span class="token comment">// 临时变量暂存 serial_tx_buffer_tail (为volatile优化)</span>

  <span class="token comment">// 从缓冲区发送一个字节到串口</span>
  UDR0 <span class="token operator">=</span> serial_tx_buffer<span class="token punctuation">[</span>tail<span class="token punctuation">]</span><span class="token punctuation">;</span>

  <span class="token comment">// 更新尾指针位置，如果已经到达顶端，返回初始位置，形成环形</span>
  tail<span class="token operator">++</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>tail <span class="token operator">==</span> TX_RING_BUFFER<span class="token punctuation">)</span> <span class="token punctuation">{</span> tail <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

  serial_tx_buffer_tail <span class="token operator">=</span> tail<span class="token punctuation">;</span>

  <span class="token comment">// 如果环形队列为空，关闭串口数据寄存器为空的中断，阻止继续发送串口流</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>tail <span class="token operator">==</span> serial_tx_buffer_head<span class="token punctuation">)</span> <span class="token punctuation">{</span> UCSR0B <span class="token operator">&amp;=</span> <span class="token operator">~</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> UDRIE0<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>代码解析：</strong></p> <p><code>ISR(SERIAL_UDRE)</code>也是一个宏定义，展开后是根据串口数据为空的中断号定义的中断处理函数，发送中断的开启是在有数据需要返回给上位机时（如<code>serial_write</code>函数被调用时）使能<code>UDRIE0</code>（串口数据寄存器为空中断使能位）实现的的，<code>UCSR0B |= (1 &lt;&lt; UDRIE0);</code>，开启中断后如果数据发送寄存器为空会立即触发中断。随后把发送队列的数据放到<code>UDR0</code>（串口数据寄存器）发送给上位机。当串口发送队列没有数据时需要禁用串口发送中断，以防止误触发中断。需要注意的是串口接收和发送都是用的<code>UDR0</code>寄存器，这样不会导致接收发送冲突吗？不会，<code>UDR0</code>的接收和发送只是共享了寄存器地址，读和写是分离在不同的硬件上实现的。</p> <h2 id="环形队列"><a href="#环形队列" class="header-anchor">#</a> 环形队列</h2> <p>环形队列是在实际编程极为有用的数据结构,它是一个首尾相连的FIFO的数据结构，采用数组的线性空间,数据组织简单。能很快知道队列是否满为空。能以很快速度的来存取数据。</p> <ol><li><p>缓冲：使用队列可以缓冲数据，提升收发数据的性能。</p></li> <li><p>高效：相比直线队列，空间利用率高。</p></li> <li><p>多任务：配合中断，串口和主循环可以在互不干扰的情况下独立工作。</p></li></ol> <p>grbl中的环形队列使用数组实现，使用两个指针标记队头队尾（不过grbl这里是反的），通过保持一个数据单元为空策略判断队列满和空。我制作了一个<a href="/demos/ringbuffer.html">演示程序</a>，想不明白的可以实操试一试更容易理解。</p> <h3 id="串口接收环形队列"><a href="#串口接收环形队列" class="header-anchor">#</a> 串口接收环形队列</h3> <div class="language-c extra-class"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">RX_BUFFER_SIZE</span></span>
  <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">RX_BUFFER_SIZE</span> <span class="token expression"><span class="token number">128</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">RX_RING_BUFFER</span> <span class="token expression"><span class="token punctuation">(</span>RX_BUFFER_SIZE<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> </span><span class="token comment">// 定义接收缓冲区环形队列长度</span></span>
<span class="token class-name">uint8_t</span> serial_rx_buffer<span class="token punctuation">[</span>RX_RING_BUFFER<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 定义串口接收环形队列</span>
<span class="token class-name">uint8_t</span> serial_rx_buffer_head <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 定义串口接收环形队列头指针</span>
<span class="token keyword">volatile</span> <span class="token class-name">uint8_t</span> serial_rx_buffer_tail <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 定义串口接收环形队列尾指针</span>
</code></pre></div><p>定义了一个<code>RX_BUFFER_SIZE</code>大小(128字节)的串口接收环形队列<code>serial_rx_buffer</code>，并使用了队头<code>serial_rx_buffer_head</code>和队尾<code>serial_rx_buffer_tail</code>两个指针记录队列状态。</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token comment">// 获取串口接收缓冲区的第一个字节。被主程序调用。</span>
<span class="token class-name">uint8_t</span> <span class="token function">serial_read</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token class-name">uint8_t</span> tail <span class="token operator">=</span> serial_rx_buffer_tail<span class="token punctuation">;</span> <span class="token comment">// 临时变量暂存 serial_rx_buffer_tail (优化volatile)</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>serial_rx_buffer_head <span class="token operator">==</span> tail<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 如果接收环形队列为空，则设置结束符号</span>
    <span class="token keyword">return</span> SERIAL_NO_DATA<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token class-name">uint8_t</span> data <span class="token operator">=</span> serial_rx_buffer<span class="token punctuation">[</span>tail<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 从接受环形队列取一个字节</span>

    tail<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">// 更新尾指针</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>tail <span class="token operator">==</span> RX_RING_BUFFER<span class="token punctuation">)</span> <span class="token punctuation">{</span> tail <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment">// 环形</span>
    serial_rx_buffer_tail <span class="token operator">=</span> tail<span class="token punctuation">;</span>

    <span class="token keyword">return</span> data<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>serial_read</code>一个读取串口环形队列的接口：这个接口在主循环中调用，它从串口接收一个字节就更新一下队尾的指针，因为使用的是数组，指针到达数组尾部要返回数组头部形成环形，如果队列是空的<code>serial_rx_buffer_head == tail</code>，就返回结束符号<code>0xff</code>。</p> <h3 id="串口发送环形队列"><a href="#串口发送环形队列" class="header-anchor">#</a> 串口发送环形队列</h3> <div class="language-c extra-class"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TX_BUFFER_SIZE</span> <span class="token expression"><span class="token number">104</span> </span><span class="token comment">// 定义串口发送缓冲区大小</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TX_RING_BUFFER</span> <span class="token expression"><span class="token punctuation">(</span>TX_BUFFER_SIZE<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> </span><span class="token comment">// 定义发送缓冲区队列长度</span></span>

<span class="token class-name">int8_t</span> serial_tx_buffer<span class="token punctuation">[</span>TX_RING_BUFFER<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 定义串口发送环形队列</span>
<span class="token class-name">uint8_t</span> serial_tx_buffer_head <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 定义串口发送环形队列头指针</span>
<span class="token keyword">volatile</span> <span class="token class-name">uint8_t</span> serial_tx_buffer_tail <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 定义串口发送环形队列尾指针</span>
</code></pre></div><p>定义了一个大小为<code>TX_BUFFER_SIZE</code>(104)的串口发送环形队列<code>serial_tx_buffer</code>，并使用了队头<code>serial_tx_buffer_head</code>和队尾<code>serial_tx_buffer_tail</code>两个指针记录队列状态。</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token comment">// 写入一个字节到串口发送缓冲区。被主程序调用。</span>
<span class="token keyword">void</span> <span class="token function">serial_write</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 计算下一个头指针，如果已经到达最大值，移到开始，形成环形</span>
  <span class="token class-name">uint8_t</span> next_head <span class="token operator">=</span> serial_tx_buffer_head <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>next_head <span class="token operator">==</span> TX_RING_BUFFER<span class="token punctuation">)</span> <span class="token punctuation">{</span> next_head <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

  <span class="token comment">// 等待，直到缓冲区有空间</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>next_head <span class="token operator">==</span> serial_tx_buffer_tail<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 代办：重构st_prep_tx_buffer()调用，在长打印期间在这里执行。</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>sys_rt_exec_state <span class="token operator">&amp;</span> EXEC_RESET<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment">// 只检查终止防止死循环。</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 储存数据并向前移动头指针</span>
  serial_tx_buffer<span class="token punctuation">[</span>serial_tx_buffer_head<span class="token punctuation">]</span> <span class="token operator">=</span> data<span class="token punctuation">;</span>
  serial_tx_buffer_head <span class="token operator">=</span> next_head<span class="token punctuation">;</span>

  <span class="token comment">// 开启数据寄存器为空的中断，确保串口发送流运行。</span>
  <span class="token comment">// 只要环形队列有空间，就可以持续不断地从串口接收数据。</span>
  UCSR0B <span class="token operator">|=</span>  <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> UDRIE0<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>serial_write</code>一个串口写入接口，这个接口主要被反馈报告程序调用，报告程序把字符串格式化之后传入这个接口，随后把传进来的数据放入发送队列，如果队列满了就一直等着，直到队列数据被串口取出留出空间，最后开启串口数据寄存器为空的中断，开启串口发送处理中断，由<code>ISR(SERIAL_UDRE)</code>将队列中的数据发送给上位机。</p> <h3 id="辅助函数"><a href="#辅助函数" class="header-anchor">#</a> 辅助函数</h3> <div class="language-c extra-class"><pre class="language-c"><code><span class="token comment">// 返回串口读缓冲区可用字节数。</span>
<span class="token class-name">uint8_t</span> <span class="token function">serial_get_rx_buffer_available</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token class-name">uint8_t</span> rtail <span class="token operator">=</span> serial_rx_buffer_tail<span class="token punctuation">;</span> <span class="token comment">// 临时变量暂存尾指针优化volatile</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>serial_rx_buffer_head <span class="token operator">&gt;=</span> rtail<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span><span class="token punctuation">(</span>RX_BUFFER_SIZE <span class="token operator">-</span> <span class="token punctuation">(</span>serial_rx_buffer_head<span class="token operator">-</span>rtail<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token keyword">return</span><span class="token punctuation">(</span><span class="token punctuation">(</span>rtail<span class="token operator">-</span>serial_rx_buffer_head<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>serial_get_rx_buffer_available</code>一个用以返回串口接收环形队列空闲字节数的接口，它会被反馈报告程序调用。它采用<code>镜像法</code>把队列尺寸扩大2倍，虚拟出另一个队列，方便计算。</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token comment">// 返回串口读缓冲区已用的字节数。</span>
<span class="token comment">// 注意：已废弃。不再被使用除非在config.h中开启了经典状态报告。</span>
<span class="token class-name">uint8_t</span> <span class="token function">serial_get_rx_buffer_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token class-name">uint8_t</span> rtail <span class="token operator">=</span> serial_rx_buffer_tail<span class="token punctuation">;</span> <span class="token comment">// 临时变量暂存尾指针优化volatile</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>serial_rx_buffer_head <span class="token operator">&gt;=</span> rtail<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span><span class="token punctuation">(</span>serial_rx_buffer_head<span class="token operator">-</span>rtail<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>RX_BUFFER_SIZE <span class="token operator">-</span> <span class="token punctuation">(</span>rtail<span class="token operator">-</span>serial_rx_buffer_head<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>返回串口接收队列已用的字节数。计算方法与上面类似。</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token comment">// 返回串口发送缓冲区已用的字节数。</span>
<span class="token comment">// 注意：没有用到除非为了调试和保证串口发送缓冲区没有瓶颈。</span>
<span class="token class-name">uint8_t</span> <span class="token function">serial_get_tx_buffer_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token class-name">uint8_t</span> ttail <span class="token operator">=</span> serial_tx_buffer_tail<span class="token punctuation">;</span> <span class="token comment">// Copy to limit multiple calls to volatile</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>serial_tx_buffer_head <span class="token operator">&gt;=</span> ttail<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span><span class="token punctuation">(</span>serial_tx_buffer_head<span class="token operator">-</span>ttail<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>TX_RING_BUFFER <span class="token operator">-</span> <span class="token punctuation">(</span>ttail<span class="token operator">-</span>serial_tx_buffer_head<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><p>返回串口发送队列已用的字节数。计算方法与上面类似。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/analysis/main.html" class="prev">
        入口
      </a></span> <span class="next"><a href="/analysis/protocol.html">
        协议-主循环
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.51868380.js" defer></script><script src="/assets/js/2.495ffcb8.js" defer></script><script src="/assets/js/1.65b8fb93.js" defer></script><script src="/assets/js/39.5056282f.js" defer></script>
  </body>
</html>
